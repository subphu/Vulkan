#version 460
#extension GL_ARB_separate_shader_objects : enable

#include "../functions/interference.glsl"

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(set=0, binding=0) buffer outputBuffer { vec4 imageData[]; };

layout(push_constant) uniform pushConstants {
    uint width, height;
    float n;
};

const int bands = 5;
const float n1 = 1.0; // refraction index air
const float n2 = 1.5; // refraction index oil

float interference(float wavelength, float delta, float opd) {

    float tot = 0.0;
    for (int i=-bands ; i<=bands ; i++) {
        float idx = float(i)/float(bands);
        float lambda = wavelength + delta * idx;
        float interference = calcInterference(lambda, opd);
        float sensitivity = cos(idx * PI)+1.0;
        tot += sensitivity * interference / float(bands*2+1);
    }
    return tot;
}

vec3 measure(float d, float theta1) {
    float theta2 = refractionAngle(n1, theta1, n2);
    float opd    = getOPD(d, theta2, n2);
    return vec3(
        interference(650e-9, 60e-9, opd),
        interference(532e-9, 40e-9, opd),
        interference(441e-9, 30e-9, opd)
    );
}

void main() {
    uint xi = gl_GlobalInvocationID.x;
    uint yi = gl_GlobalInvocationID.y;

    if(xi >= width || yi >= height) return;
    
    float xf = float(xi) / float(width);
    float yf = float(yi) / float(height);
    vec2  uv = vec2(xf, yf);

    float thickness  = 4e-6 * uv.y;
    float angle      = PI/2 * uv.x;

    vec3 col = measure(thickness, angle);

    uint idx = yi * width + xi;
    imageData[idx] = vec4(col, 1.0);
}
